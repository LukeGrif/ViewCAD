<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>CAD Viewer</title>

<style>
  body {
    margin: 0;
    background: #0d0f1a;
    color: white;
    font-family: Arial, sans-serif;
    overflow: hidden;
  }

  .viewer-panel {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle at top, #171c3b 0, #050713 45%, #02030a 100%);
  }

  #viewer-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }

  .ui-panel {
    position: absolute;
    top: 10px;
    left: 10px;
    padding: 12px;
    background: rgba(20, 20, 35, 0.6);
    backdrop-filter: blur(8px);
    border-radius: 8px;
    border: 1px solid #4c5eff33;
  }

  .ui-panel h2 {
    margin: 0 0 6px 0;
    font-size: 15px;
  }

  .ui-panel label,
  .ui-panel button {
    display: block;
    margin-top: 6px;
  }

  button {
    padding: 7px 11px;
    background: #2a2f52;
    border: 1px solid #4c5eff55;
    color: white;
    border-radius: 5px;
    cursor: pointer;
  }

  button.active {
    background: #4c5eff;
  }

  #errorText {
    color: #ff6262;
    font-weight: bold;
    display: none;
  }
</style>
</head>

<body>

<div class="viewer-panel">
  <canvas id="viewer-canvas"></canvas>
</div>

<!-- UI PANEL -->
<div class="ui-panel">
  <h2 id="modelTitle">Model Viewer</h2>

  <label>Status: <span id="statusText">Idle</span></label>
  <label style="color:#ff5f5f;" id="errorText"></label>

  <label>File: <span id="fileName">None</span></label>
  <label>Bounds: <span id="boundsLabel">-</span></label>
  <label>Triangles: <span id="trianglesLabel">-</span></label>
  <label>Polygons: <span id="polyCount">-</span></label>
  <label>Environment: <span id="envLabel">Studio</span></label>

  <button id="resetViewBtn">Reset View</button>
  <button id="autoRotateBtn">Auto Rotate</button>
  <button id="wireframeBtn">Wireframe</button>
  <button id="bgToggleBtn">Background</button>

  <label><input type="checkbox" id="gridToggle" checked /> Grid</label>
  <label><input type="checkbox" id="shadowToggle" checked /> Shadows</label>

  <br>
  <input type="file" id="fileInput" />
</div>

<!-- FIX: Import map so "three" resolves properly -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js"
  }
}
</script>

<!-- MAIN MODULE SCRIPT -->
<script type="module">
import * as THREE from "three";
import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/loaders/GLTFLoader.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/controls/OrbitControls.js";

let scene, camera, renderer, controls;
let model = null;
let gridHelper = null;
let floorMesh = null;
let dirLight = null;
let autoRotate = false;
let wireframeEnabled = false;
let darkBg = true;

const canvas = document.getElementById("viewer-canvas");
const statusText = document.getElementById("statusText");
const fileNameEl = document.getElementById("fileName");
const boundsLabel = document.getElementById("boundsLabel");
const trianglesLabel = document.getElementById("trianglesLabel");
const errorText = document.getElementById("errorText");
const polyCountEl = document.getElementById("polyCount");
const envLabel = document.getElementById("envLabel");
const modelTitleEl = document.getElementById("modelTitle");

function setStatus(msg, isError = false) {
  statusText.textContent = msg;
  errorText.style.display = isError ? "block" : "none";
  errorText.textContent = isError ? msg : "";
}

function init() {
  scene = new THREE.Scene();

  const aspect = canvas.clientWidth / canvas.clientHeight;
  camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 5000);
  camera.position.set(150, 120, 150);

  renderer = new THREE.WebGLRenderer({
    canvas,
    antialias: true,
    alpha: true,
  });
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.shadowMap.enabled = true;

  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x101020, 0.8);
  hemiLight.position.set(0, 200, 0);
  scene.add(hemiLight);

  dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
  dirLight.position.set(140, 180, 90);
  dirLight.castShadow = true;
  scene.add(dirLight);

  const floorGeo = new THREE.PlaneGeometry(1000, 1000);
  const floorMat = new THREE.ShadowMaterial({ opacity: 0.28 });
  floorMesh = new THREE.Mesh(floorGeo, floorMat);
  floorMesh.rotation.x = -Math.PI / 2;
  floorMesh.receiveShadow = true;
  scene.add(floorMesh);

  gridHelper = new THREE.GridHelper(600, 60, 0x4c5eff, 0x22294a);
  scene.add(gridHelper);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.target.set(0, 60, 0);

  setBackground(true);
  window.addEventListener("resize", onWindowResize);
  animate();

  loadGLB("models/model.glb");
}

function onWindowResize() {
  camera.aspect = canvas.clientWidth / canvas.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(canvas.clientWidth, canvas.clientHeight);
}

function setBackground(isDark) {
  darkBg = isDark;
  const viewerPanel = document.querySelector(".viewer-panel");
  viewerPanel.style.background = isDark
    ? "radial-gradient(circle at top, #171c3b 0, #050713 45%, #02030a 100%)"
    : "radial-gradient(circle at top, #e6edf8 0, #aebad1 40%, #7c879a 100%)";
}

function animate() {
  requestAnimationFrame(animate);

  if (autoRotate && model) model.rotation.y += 0.005;

  controls.update();
  renderer.render(scene, camera);
}

function clearModel() {
  if (!model) return;
  scene.remove(model);
  model = null;
}

function fitCameraToObject(object, offset = 1.4) {
  const box = new THREE.Box3().setFromObject(object);
  const size = new THREE.Vector3();
  const center = new THREE.Vector3();
  box.getSize(size);
  box.getCenter(center);

  const maxDim = Math.max(size.x, size.y, size.z);
  const fov = camera.fov * (Math.PI / 180);
  let cameraZ = Math.abs((maxDim / 2) / Math.tan(fov / 2)) * offset;

  camera.position.set(center.x + cameraZ, center.y + cameraZ * 0.6, center.z + cameraZ);
  controls.target.copy(center);
}

function updateStats(object) {
  let count = 0;
  object.traverse((child) => {
    if (child.isMesh) {
      const geom = child.geometry;
      if (geom.index) count += geom.index.count / 3;
      else count += geom.attributes.position.count / 3;
    }
  });

  trianglesLabel.textContent = count.toLocaleString();
  polyCountEl.textContent = count.toLocaleString();
}

function loadGLB(srcOrFile) {
  setStatus("Loading modelâ€¦");
  clearModel();

  const loader = new GLTFLoader();

  loader.load(
    srcOrFile,
    (gltf) => onModelLoaded(gltf, srcOrFile),
    undefined,
    (err) => {
      console.error(err);
      setStatus("Failed to load model", true);
    }
  );
}

function onModelLoaded(gltf, name) {
  model = gltf.scene;
  scene.add(model);

  modelTitleEl.textContent = "Design: " + name;
  fileNameEl.textContent = name;

  fitCameraToObject(model);
  updateStats(model);

  setStatus("Loaded");
}

document.getElementById("fileInput").addEventListener("change", (e) => {
  const file = e.target.files[0];
  if (!file) return;
  if (!file.name.match(/\.(glb|gltf)$/i)) {
    setStatus("Only .glb / .gltf supported", true);
    return;
  }

  const url = URL.createObjectURL(file);
  loadGLB(url);
});

document.getElementById("resetViewBtn").addEventListener("click", () => {
  if (!model) return;
  autoRotate = false;
  fitCameraToObject(model);
});

document.getElementById("autoRotateBtn").addEventListener("click", (e) => {
  autoRotate = !autoRotate;
  e.target.classList.toggle("active", autoRotate);
});

document.getElementById("wireframeBtn").addEventListener("click", (e) => {
  wireframeEnabled = !wireframeEnabled;
  e.target.classList.toggle("active", wireframeEnabled);

  if (model) {
    model.traverse((child) => {
      if (child.isMesh) child.material.wireframe = wireframeEnabled;
    });
  }
});

document.getElementById("bgToggleBtn").addEventListener("click", () => {
  setBackground(!darkBg);
});

document.getElementById("gridToggle").addEventListener("change", (e) => {
  gridHelper.visible = e.target.checked;
});

document.getElementById("shadowToggle").addEventListener("change", (e) => {
  dirLight.castShadow = e.target.checked;
});

init();
</script>

</body>
</html>
